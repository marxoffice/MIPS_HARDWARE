# MIPS_HARDWARE
MipsVerilog

## **信号控制码译码信号**

| 指令说明 | instruction | op[5:0]/funct[5:0] | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| -------- | :---------: | :----------------: | :------: | :----: | :----: | :----: | :------: | :------: | ---- |
|          |   R-type    |       000000       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     lw      |       100011       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     sw      |       101011       |    0     |   x    |   1    |   0    |    1     |    x     | 0    |
|          |     beq     |       000100       |    0     |   x    |   0    |   1    |    0     |    x     | 0    |
|          |    addi     |       001000       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |      j      |       000010       |    0     |   x    |   x    |   x    |    0     |    x     | 1    |
|          |             |                    | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| logic    |     and     |       100100       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     or      |       100101       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     xor     |       100110       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     nor     |       100111       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    andi     |       001100       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |    xori     |       001110       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |     lui     |       001111       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |     ori     |       001101       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |             |                    | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| shift    |     sll     |       000000       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     srl     |       000010       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     sra     |       000011       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    sllv     |       000100       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    srlv     |       000110       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    srav     |       000111       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |             |                    | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| move     |    mfhi     |       010000       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    mflo     |       010010       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    mthi     |       010001       |    0     |   0    |   0    |   0    |    0     |    0     | 0    |
|          |    mtlo     |       010011       |    0     |   0    |   0    |   0    |    0     |    0     | 0    |
|          |             |                    | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| 算术     |     add     |       100000       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    addu     |       100001       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     sub     |       100010       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    subu     |       100011       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     slt     |       101010       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    sltu     |       101011       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    mult     |       011000       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    multu    |       011001       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |     div     |       011010       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    divu     |       011011       |    1     |   1    |   0    |   0    |    0     |    0     | 0    |
|          |    addi     |       001000       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |    addiu    |       001001       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |    slti     |       001010       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |    sltiu    |       001011       |    1     |   0    |   1    |   0    |    0     |    0     | 0    |
|          |             |                    | regwrite | regdst | alusrc | branch | memWrite | memtoReg | jump |
| 访存     |     lb      |       100000       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     lbu     |       100100       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     lh      |       100001       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     lhu     |       100101       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     lw      |       100011       |    1     |   0    |   1    |   0    |    0     |    1     | 0    |
|          |     sb      |       101000       |    0     |   0    |   1    |   0    |    1     |    0     | 0    |
|          |     sh      |       101001       |    0     |   0    |   1    |   0    |    1     |    0     | 0    |
|          |     sw      |       101011       |    0     |   0    |   1    |   0    |    1     |    0     | 0    |
|          |             |                    |          |        |        |        |          |          |      |
|          |             |                    |          |        |        |        |          |          |      |
|          |             |                    |          |        |        |        |          |          |      |
|          |             |                    |          |        |        |        |          |          |      |
|          |             |                    |          |        |        |        |          |          |      |



## 工作日志

#### 2020.12.25

|    时间     |  人员  |                           工作内容                           |
| :---------: | :----: | :----------------------------------------------------------: |
| 10:00-12:00 | 屈湘钧 | 复习计组4的简单五级流水线cpu，并大致整理任务目标和初步的上手想法。 |
| 15:00-18:00 | 屈湘钧 | 学习吕学长教学视频1、2关于57条指令添加教程，并大致思考了添加指令的第一步译码做法，计划明天开始正式开始写controller中的译码和alu译码，分类添加指令集。 |
| 8:00-18:00  | 朱海龙 |             分析实验通路，阅读soc，axi，sram资料             |

#### 2020.12.26

|    时间     |  人员  |                           工作内容                           |
| :---------: | :----: | :----------------------------------------------------------: |
| 10:10-12:00 | 屈湘钧 |                    基本写完alu_dec.v文件                     |
| 14:20-18:00 | 屈湘钧 | 完成大部分逻辑运算指令添加工作；变更指令编码后的计组4测试调试通过 |
| 8:50-17:30  | 朱海龙 |       阅读测试文档，初步完成main_dec和controller的编写       |

#### 2020.12.27

|    时间     |  人员  |                  工作内容                   |
| :---------: | :----: | :-----------------------------------------: |
| 14:40-18:00 | 屈湘钧 |     完成逻辑运算指令8条的添加和测试工作     |
| 9:00-18:30  | 朱海龙 | 完成移位指令添加，完成部分hilo_move指令添加 |

#### 2020.12.28

|    时间     |  人员  |                        工作内容                         |
| :---------: | :----: | :-----------------------------------------------------: |
| 14:30-24:00 | 屈湘钧 |    听课，做算术指令的添加，已完成初步代码，正在测试     |
| 8:30-12:00  | 朱海龙 | 完成数据移动指令，修复移位指令bug，完成这两类指令的测试 |

#### 2020.12.29

|    时间     |  人员  |                          工作内容                          |
| :---------: | :----: | :--------------------------------------------------------: |
| 13:00-17:45 | 屈湘钧 | 完成算术指令14条的添加与测试通过，初步想好了访存指令的构建 |
| 8:30-12:00  | 朱海龙 |   完成分支branch指令(包含分支预测)，并完成分支branch测试   |

#### 2020.12.30

<<<<<<< HEAD
|    时间     |  人员  |                      工作内容                       |
| :---------: | :----: | :-------------------------------------------------: |
| 10:30-12:30 | 屈湘钧 |                     做访存指令                      |
| 14:30-19:30 | 屈湘钧 | 基本完成访存指令代码，测试通过计组4，还未做单元测试 |
|             |        |                                                     |
=======
|    时间     |  人员  |                          工作内容                          |
| :---------: | :----: | :--------------------------------------------------------: |
| 13:00-17:45 | 屈湘钧 | 完成算术指令14条的添加与测试通过，初步想好了访存指令的构建 |
| 8:30-12:00  | 朱海龙 |  完成跳转jump指令(包含jal的数据前推)，并完成跳转jump测试   |
>>>>>>> da49dd27f20c51a0f17b81db23c2361f23c04542



## 测试日志

|    时间    |  人员  |           测试            |
| :--------: | :----: | :-----------------------: |
| 2020.12.27 | 屈湘钧 | logic8条指令部分测试完成  |
| 2020.12.28 | 朱海龙 | shift6条指令部分测试完成  |
| 2020.12.28 | 朱海龙 | move_hilo四条指令测试完成 |
| 2020.12.29 | 屈湘钧 |   运算指令14条测试完毕    |
| 2020.12.29 | 朱海龙 |    分支指令branch测试     |
| 2020.12.30 | 朱海龙 |     跳转指令jump测试      |

## 添加指令过程截图

#### 逻辑指令测试完成

```assembly
   lui  $1,0x0101
   ori  $1,$1,0x0101
   ori  $2,$1,0x1100        # $2 = $1 | 0x1100 = 0x01011101
   or   $1,$1,$2            # $1 = $1 | $2 = 0x01011101
   andi $3,$1,0x00fe        # $3 = $1 & 0x00fe = 0x00000000
   and  $1,$3,$1            # $1 = $3 & $1 = 0x00000000
   xori $4,$1,0xff00        # $4 = $1 ^ 0xff00 = 0x0000ff00
   xor  $1,$4,$1            # $1 = $4 ^ $1 = 0x0000ff00
   nor  $1,$4,$1            # $1 = $4 ~^ $1 = 0xffff00ff   nor is "not or"
```

![image-20201227172257935](.\imgs\逻辑运算测试20201227172257935.png)

#### 移位指令测试完成

```asm
   lui   $2,0x0404
   ori   $2,$2,0x0404
   ori   $7,$0,0x7
   ori   $5,$0,0x5
   ori   $8,$0,0x8
   sll   $2,$2,8    ## $2 = 0x40404040 sll 8  = 0x04040400
   sllv  $2,$2,$7   ## $2 = 0x04040400 sll 7  = 0x02020000
   srl   $2,$2,8    ## $2 = 0x02020000 srl 8  = 0x00020200
   srlv  $2,$2,$5   ## $2 = 0x00020200 srl 5  = 0x00001010
   nop
   sll   $2,$2,19   ## $2 = 0x00001010 sll 19 = 0x80800000
   sra   $2,$2,16   ## $2 = 0x80800000 sra 16 = 0xffff8080
   srav  $2,$2,$8   ## $2 = 0xffff8080 sra 8  = 0xffffff80 
```

![TestShift](./imgs/功能移位测试20201228094539.png)

#### 数据移动指令测试完毕

```assembly
   lui $1,0x0000          # $1 = 0x00000000
   lui $2,0xffff          # $2 = 0xffff0000
   lui $3,0x0505          # $3 = 0x05050000
   lui $4,0x0000          # $4 = 0x00000000 

   mthi $0                ## hi = 0x00000000
   mthi $2                ## hi = 0xffff0000
   mthi $3                ## hi = 0x05050000
   mfhi $4                ## $4 = 0x05050000

   mtlo $3                ## lo = 0x05050000
   mtlo $2                ## lo = 0xffff0000
   mtlo $1                ## lo = 0x00000000
   mflo $4                ## $4 = 0x00000000        
## 下图中出现的红色信号的原因是前几条指令一直在操作hi，所以lo就一直是未定义状态
```

![TestShift](./imgs/数据移动测试20201228102906.png)

#### 简单算术指令测试（包含乘法，不包含除法）

```assembly
   ######### add\addi\addiu\addu\sub\subu ##########

   ori  $1,$0,0x8000           # $1 = 0x8000
   sll  $1,$1,16               # $1 = 0x80000000
   ori  $1,$1,0x0010           # $1 = 0x80000010

   ori  $2,$0,0x8000           # $2 = 0x8000
   sll  $2,$2,16               # $2 = 0x80000000
   ori  $2,$2,0x0001           # $2 = 0x80000001

   ori  $3,$0,0x0000           # $3 = 0x00000000
   addu $3,$2,$1               # $3 = 0x00000011
   ori  $3,$0,0x0000           # $3 = 0x00000000
   add  $3,$2,$1               # overflow,$3 keep 0x00000000

   sub   $3,$1,$3              # $3 = 0x80000010         
   subu  $3,$3,$2              # $3 = 0xF

   addi $3,$3,2                # $3 = 0x11
   ori  $3,$0,0x0000           # $3 = 0x00000000
   addiu $3,$3,0x8000          # $3 = 0xffff8000

   #########     slt\sltu\slti\sltiu     ##########

   ori   $1,$0,0xffff           # $1 = 0xffff
   sll  $1,$1,16               # $1 = 0xffff0000
   slt  $2,$1,$0               # $2 = 1
   sltu $2,$1,$0               # $2 = 0
   slti $2,$1,0x8000           # $2 = 1
   sltiu $2,$1,0x8000          # $2 = 1

   #########          mult/multu          ##########

   ori  $1,$0,0xffff           # $1 = 0xffff
   sll  $1,$1,16               # $1 = 0xffff0000
   ori  $1,$1,0xfffb           # $1 = -5
   ori  $2,$0,6                # $2 = 6  
   mult $1,$2                  # hi = 0xffffffff
                               # lo = 0xffffffe2

   multu $1,$2                 # hi = 0x5
                               # lo = 0xffffffe2
   nop
   nop
```

![image-20201229142339508](./imgs/简单算术指令测试20201229142339508.png)

![image-20201229142736599](./imgs/乘法算术指令测试20201229142339508.png)

#### 除法运算指令测试

```assembly
   ori  $2,$0,0xffff                  
   sll  $2,$2,16
   ori  $2,$2,0xfff1           # $2 = -15
   ori  $3,$0,0x11             # $3 = 17

   div $zero,$2,$3             # hi = 0xfffffff1            
                               # lo = 0x0
   divu $zero,$2,$3            # hi = 0x00000003
                               # lo = 0x0f0f0f0e

   div  $zero,$3,$2            # hi = 2
                               # lo = 0xffffffff
```

图1为DIV和DIVU的结果，图2位DIVU和DIV的结果。

图3为DIV与DIVU指令间，需要stall流水线的信号和结果ok的信号。

![image-20201229152854065](./imgs/除法运算测试1.png)

![image-20201229152758889](./imgs/除法运算测试2.png)

![image-20201229153015814](./imgs/除法运算测试3.png)

#### 分支branch指令测试

```assembly
   .org 0x0
   .set noat
   .set noreorder
   .set nomacro
   .global _start
_start:
   ori  $3,$0,0x8000
   sll  $3,16               # $3 = 0x80000000
   ori  $1,$0,0x0001        ## $1 = 0x1                
   b    sec1
   ori  $1,$0,0x0002        ## $1 = 0x2
1:
   ori  $1,$0,0x1111
   ori  $1,$0,0x1100

   .org 0x20
sec1:
   ori  $1,$0,0x0003        ## $1 = 0x3          
   bal  s2
   ori  $1,$0,0x1100
   ori  $1,$0,0x1111
   bne  $1,$0,s3
   nop
   ori  $1,$0,0x1100
   ori  $1,$0,0x1111

   .org 0x50   
s2:
   ori  $1,$0,0x0004      ## $1 = 0x4
   beq  $3,$3,s3           
   or   $1,$31,$0         ## $1 = 0x2c
   ori  $1,$0,0x1111
   ori  $1,$0,0x1100
2:
   ori  $1,$0,0x0007      ## $1 = 0x7
   ori  $1,$0,0x0008      ## $1 = 0x8
   bgtz $1,s4
   ori  $1,$0,0x0009      ## $1 = 0x9
   ori  $1,$0,0x1111
   ori  $1,$0,0x1100

   .org 0x80
s3:
   ori  $1,$0,0x0005      ## $1 = 0x5            
   BGEZ $1,2b           
   ori  $1,$0,0x0006      ## $1 = 0x6
   ori  $1,$0,0x1111
   ori  $1,$0,0x1100

   .org 0x100
s4:
   ori  $1,$0,0x000a      ## $1 = 0xa              
   BGEZAL $3,s3
   or   $1,$0,$31         ## $1 = 0x10c          
   ori  $1,$0,0x000b      ## $1 = 0xb
   ori  $1,$0,0x000c      ## $1 = 0xc
   ori  $1,$0,0x000d      ## $1 = 0xd
   ori  $1,$0,0x000e      ## $1 = 0xe
   bltz $3,s5
   ori  $1,$0,0x000f      ## $1 = 0xf
   ori  $1,$0,0x1100


   .org 0x130
s5:
   ori  $1,$0,0x0010      ## $1 = 0x10            
   blez $1,2b           
   ori  $1,$0,0x0011      ## $1 = 0x11
   ori  $1,$0,0x0012      ## $1 = 0x12
   ori  $1,$0,0x0013      ## $1 = 0x13
   bltzal $3,s6
   or   $1,$0,$31         ## $1 = 0x14c
   ori  $1,$0,0x1100


   .org 0x160
s6:
   ori $1,$0,0x0014       ## $1 = 0x14
   nop
   
   
    
_loop:
   j _loop
   nop

## 下图中包含了分支预测功能，因此可能部分过程与普通流水线不同，但大致路径相同
## predictD信号是预测是否跳转的信号
```

![BranchTest](./imgs/BranchTest202012291113033.png)

#### 跳转jump指令测试

```assembly
   .org 0x0
   .set noat
   .set noreorder
   .set nomacro
   .global _start
_start:
   addiu  $1,$0,0x0001   ## $1 = 0x1                
   j    0x20
   addiu  $1,$1,0x0001   ## $1 = 0x2
   addiu  $1,$1,0x1111
   addiu  $1,$1,0x1100

   .org 0x20
   addiu  $1,$1,0x0001   ## $1 = 0x3               
   jal  0x40
   nop
   addiu  $1,$1,0x0001   ## r1 = 0x4
   addiu  $1,$1,0x0001   ## r1 = 0x5
   j    0x60
   nop

   .org 0x40
               
   jalr $2,$31           
   or   $3,$2,$0          ## $3 = 0xb0000048
   addiu  $1,$1,0x0001    ## $1 = 0x8
   addiu  $1,$1,0x0001    ## $1 = 0x9
   addiu  $1,$1,0x0001    ## $1 = 0xa
   j 0x80
   nop

   .org 0x60
   addiu  $1,$1,0x0001    ## $1 = 0x6              
   jr   $3          
   addiu  $1,$1,0x0001    ## $1 = 0x7
   addiu  $1,$1,0x1111
   addiu  $1,$1,0x1100

   .org 0x80
   nop
    
_loop:
   j _loop
   nop

## 注意jal 以及 jalr类型的指令需要进行数据前推
## 注意j型指令延迟槽的设计
## ra是第31号寄存器，这里为了测试把它放出来，正常情况不能允许访问，由于数据前推机制，更新会在WB，但是可以正常读正确ra出来
```

![JinstTest](./imgs/JinstTest202012301052.png)

## 错误日志

##### 2020.12.27

###### 错误1

错误原因：在通路文件mipsflows的alucontroller的信号位数未改完全，导致仿真时信号传输有x或z

解决方案：修改alucontroller涉及的中间寄存器和转存信号的位数，如alucontrollerD、alucontrollerE。

##### 2020.12.29

###### 错误1

错误描述：ALU_OP字符复制粘贴错误，导致计算未正确执行，使用了default的0结果。

解决方案：对照alu_dec文件逐一检查更新字符。

##### 2020.12.30

###### 错误1

错误描述：访存做完后测试计组4代码发现sw写入有问题

解决方案：最终查询发现计组4的sw写入地址不是4的整数倍



## 引用说明

##### 乘法器引用

本项目中乘法器引用了https://github.com/14010007517/2020NSCSCC.git中的乘法器1.0版本

##### 除法器引用

本项目中除法器引用了https://github.com/14010007517/2020NSCSCC.git中的除法器1.4版本

